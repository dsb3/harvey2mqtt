#!/usr/bin/env python3
#
# harvey2mqtt
#
# Dave Baker <dave@dsb3.com>
#
# Given environment variables that permit logging into the Harvey SWS interface, scrape
# device information, and pass through to MQTT broker under harvey2mqtt/ prefix
#
# If JSONs are present, also inject MQTT auto-configuration entries for Home Assistant.
#
#
# CHANGELOG
#  2023-12-23  dbaker   Updated to loop and handle AWS/Cognito and MQTT in single script
#  2023-12-02  dbaker   Initial "one shot" script, requiring python and bash to update
#

import os, glob, time, json, socket
from datetime import datetime, timedelta


import boto3, requests
from pycognito.aws_srp import AWSSRP
from pycognito import Cognito
from requests_aws4auth import AWS4Auth

import paho.mqtt.client as mqtt


# parameters for mqtt interface
mqtthost = os.getenv("MQTTHOST", default="localhost")
mqttport = os.getenv("MQTTPORT", default="1883")

mqttuser = os.getenv("MQTTUSER", default=False)
mqttpass = os.getenv("MQTTPASS", default=False)

# parameters for harvey interface
harveyuser = os.environ['HARVEYUSER']
harveypass = os.environ['HARVEYPASS']


# timestamp on when we want to poll for updates - this initial value
# means to poll immediately when ready
poll = datetime.now()
printtime = datetime.now()


# The callback for when the client receives a CONNACK response from the server.
# TODO: rc=5 is a "wrong password" response.  If there are too many errors, we
# should exit and let the container running the script respawn.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code "+str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.subscribe("harvey2mqtt/poll/#")

    # Publishing in on_connect() means we are sure to resend autoconfig
    # when we start, or need to reconnect to the broker
    client.publish("harvey2mqtt/bridge/state", "online")

    # Any time we re-connect to the MQTT broker, do a poll as soon as possible
    # in case it's beneficial
    global poll
    poll = datetime.now()




# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic+" "+str(msg.payload))

    # crude = just accept any poll activity to mean "poll now"
    global poll
    poll = datetime.now()




# In a container, the fqdn will be the full pod name
client = mqtt.Client(client_id="h2m-" + socket.getfqdn())
client.on_connect = on_connect
client.on_message = on_message

# TODO: support tls and/or wss
print ("Host " + mqtthost + "  port " + mqttport)

# if user/pass are both defined
if mqttuser and mqttpass:
  client.username_pw_set(mqttuser, password=mqttpass)


# LWT
## enable when ready; disabled for now to not mark the "other" h2m process I have running as offline while I test
# client.will_set("harvey2mqtt/bridge/state", payload="offline", retain=True)

client.connect(mqtthost, int(mqttport), 30)


# Start MQTT process in background
client.loop_start()


# Do the first time login to the harvey interface.

## all hard coded values taken from watching traffic generated by the mobile app.  It's also
## in the Android APK if you want to disassemble it and extract the strings.

identityid = 'eu-west-1:30070db9-1478-46b4-ae5a-7d38053cd66c'
poolid     = 'eu-west-1_gtX9aUXzh'
clientid   = '67c9dtgnbjid8l9dh5juih2iq4'
loginsid   = 'cognito-idp.eu-west-1.amazonaws.com/' + poolid

# Authenticate ... this gives AccessToken, RefreshToken, etc
botoclient = boto3.client('cognito-idp', 'eu-west-1')
aws = AWSSRP(username=harveyuser, password=harveypass, pool_id=poolid, client_id=clientid, client=botoclient)
tokens = aws.authenticate_user()

# debug - print them
#tokens['AuthenticationResult']['IdToken']}

# Get Credentials ... this gives us AccessKey, SecretKeyId, etc
cog = boto3.client('cognito-identity', 'eu-west-1')


# If we want a one-shot, without option to check_token() to renew, we could just run cog.get_credentials()
# here, and not bother with the u = Cognito(...) part.
#### r = cog.get_credentials_for_identity( IdentityId = identityid, Logins={loginsid: tokens['AuthenticationResult']['IdToken']} )


# todo - switch out for constant vars for the settings
u = Cognito(poolid, clientid, id_token=tokens['AuthenticationResult']['IdToken'], refresh_token=tokens['AuthenticationResult']['RefreshToken'], access_token=tokens['AuthenticationResult']['AccessToken'])




while True:

    # Debug to print timestamp just once every hour, but we sleep in one
    # minute blocks to allow for faster "poll now" requests
    if datetime.now() > printtime:
      print ( datetime.now() )
      printtime = datetime.now() + timedelta(hours = 30)

      # debugging - print every minute
      #printtime = datetime.now() + timedelta(minutes = 1)


    if datetime.now() > poll:
        print ("  polling ...")
        poll = datetime.now() + timedelta(minutes = 45)

        # Check and refresh our token if it's needed
        u.check_token()

        # This will (presumably) fail if the refresh token is also expired
        try:
            r = cog.get_credentials_for_identity( IdentityId = identityid, Logins={loginsid: u.id_token})
            # debug - print them
            ###  r['Credentials']['AccessKeyId']
        except botocore.errorfactory.NotAuthorizedExceptioni as e:
            print ("Failed to get credentials for identity - presumed refresh token expired")
            print ( datetime.now() )
            print (e.message)
            print (e.args)

            ### I don't know how far back to start in the process
            ### to do -- how often do we need to back to re-auth?  12 hours might be a default.
            tokens = aws.authenticate_user()
            u = Cognito(poolid, clientid, id_token=tokens['AuthenticationResult']['IdToken'], refresh_token=tokens['AuthenticationResult']['RefreshToken'], access_token=tokens['AuthenticationResult']['AccessToken'])
            r = cog.get_credentials_for_identity( IdentityId = identityid, Logins={loginsid: u.id_token})

            ## todo - if this also fails, we need to restart earlier and log in from even sooner.



        # Use the AWS4Auth to sign our request, and python requests to call the API
        auth = AWS4Auth( r['Credentials']['AccessKeyId'], r['Credentials']['SecretKey'], 'eu-west-1', 'execute-api', session_token=r['Credentials']['SessionToken'] )
        response = requests.get('https://y7xyrocicl.execute-api.eu-west-1.amazonaws.com/prod/v1/softeners/all', auth=auth)

        ## currently we just support a single water softener (json element 0)
        try:
            jsonall = json.loads(response.text)
            jsondata = jsonall[0]
        except:
            print ("Dataset is not JSON")
            print (response.text)
            client.publish("harvey2mqtt/" + hdata["SERIAL"] + "/availability", "offline")
            jsondata = {}


        ## Valid dataset??
        # todo - if invalid data is seen "too many times", just exit and allow
        # the container running this script to respawn fresh
        if "ssn" not in jsondata.keys():
            print ("Dataset is invalid")
            print (json.dumps(jsondata))
            client.publish("harvey2mqtt/" + hdata["SERIAL"] + "/availability", "offline")


        else:
            ## delete the json entries we don't want to pass through
            jsondata.pop("thresholds", None)
            jsondata.pop("dealer", None)
            jsondata.pop("location", None)
            jsondata.pop("dummy", None)
    
            ## extract info for autoconfig json entries
            hdata = {
              "SERIAL": jsondata["ssn"].replace("/", "_"),
              "MODEL":  jsondata["dsn"],
              "SWVER":  jsondata["fwVersion"],
              "BRAND":  jsondata["brand"]
            }
    
    
            ## Send the (re)configuration entries
    
            # for file in glob.glob("/path/*.json"):
            #     print (file)

            ##  ''' some string {SERIAL} ...'''.format(**hdata)
    
            ## Send availability
            #    todo - mark offline if jsondata["lastUpdate"] is too old
            client.publish("harvey2mqtt/" + hdata["SERIAL"] + "/availability", "online")
    
            ## Send the payload
            client.publish("harvey2mqtt/" + hdata["SERIAL"], json.dumps(jsondata), retain=True)
    
            print (json.dumps(jsondata))



    # Wait between runs
    time.sleep(60)




